/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 stargate.glb -t -r ./ 
*/

import * as THREE from 'three'
import React, { forwardRef, useEffect, useMemo, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import { GroupProps, useFrame } from '@react-three/fiber'
import { GLTF } from 'three-stdlib'
import { Group } from 'three';

type GLTFResult = GLTF & {
  nodes: {
    Lock_Light001: THREE.Mesh
    Stargate001: THREE.Mesh
    Glyphs001: THREE.Mesh
    Ring001: THREE.Mesh
    Lock_Light002: THREE.Mesh
  }
  materials: {
    Stargate_Lock_L: THREE.MeshStandardMaterial
    Stargate_Main: THREE.MeshStandardMaterial
    Stargate_Glyphs: THREE.MeshStandardMaterial
    Stargate_Ring: THREE.MeshStandardMaterial
  }
}

type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['mesh']>>

type SpaceShipProps = JSX.IntrinsicElements['group'] & {
  scale: number;
  position: [number, number, number];
  rotation: [number, number, number];
  isEmissive: boolean;
  currentMovementSpeed: number;
};

export const Stargate = forwardRef<Group, SpaceShipProps>(({ scale, position, rotation, isEmissive, currentMovementSpeed }, ref) => {
  const { nodes, materials } = useGLTF('models/stargate.glb') as GLTFResult

  // Clonar el material para esta instancia específica
  const emissiveMaterial = useMemo(() => materials.Stargate_Lock_L.clone(), [materials.Stargate_Lock_L]);
  const [hue, setHue] = useState(0);
  const [additionalRotation, setAdditionalRotation] = useState(0);

  useFrame(({ clock }) => {
    if (isEmissive) {
      const time = clock.getElapsedTime();
      const intensity = Math.abs(Math.sin(time * 4)) * 1;
      setHue((time % 4 * (Math.abs(currentMovementSpeed * 2) + 1)) / 4 * (Math.abs(currentMovementSpeed * 2) + 1));
      emissiveMaterial.emissiveIntensity = intensity;
      emissiveMaterial.emissive.setHSL(hue, 1, 0.5);

      const rotationSpeedFactor = currentMovementSpeed * 4; // Normalizar a [0, 1]
      setAdditionalRotation(rotationSpeedFactor * Math.PI * 2) // Ajuste este valor según sea necesario
    } else {
      emissiveMaterial.emissiveIntensity = 0;
      emissiveMaterial.emissive.setHSL(0, 0, 0);
    }

  });


  return (
    <group ref={ref} scale={scale} position={position} rotation={[rotation[0], rotation[1], rotation[2] + hue * Math.PI * 2]} dispose={null}>
      <mesh geometry={nodes.Lock_Light001.geometry} material={emissiveMaterial} />
      <mesh geometry={nodes.Stargate001.geometry} material={materials.Stargate_Main} />
      <mesh geometry={nodes.Glyphs001.geometry} material={materials.Stargate_Glyphs} />
      <mesh geometry={nodes.Ring001.geometry} material={materials.Stargate_Ring} />
      <mesh geometry={nodes.Lock_Light002.geometry} material={emissiveMaterial} position={[0, 0, -0.008]} rotation={[3.139, -0.003, 3.141]} />
    </group>
  )
});

useGLTF.preload('models/stargate.glb')
